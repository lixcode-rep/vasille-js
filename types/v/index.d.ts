import { debug, text } from "../functional/components";
import { arrayModel, mapModel, objectModel, setModel } from "../functional/models";
import { expr, forward, mirror, point, ref, setValue, valueOf, watch } from "../functional/reactivity";
import { app, component, create, extension, fragment, tag } from "../functional/stack";
import { Options, TagOptions } from "../functional/options";
import { AppOptions } from "../node/app";
import { Reference } from "../value/reference";
import { merge } from "../functional/merge";
export { debug, arrayModel, mapModel, objectModel, setModel, expr, forward, mirror, point, ref, setValue, valueOf, watch, Options, TagOptions, AppOptions };
export declare const v: {
    merge: typeof merge;
    destructor(): any;
    runOnDestroy(callback: () => void): void;
    if(condition: import("../index").IValue<boolean>, callback: () => void): void;
    else(callback: () => void): void;
    elif(condition: import("../index").IValue<boolean>, callback: () => void): void;
    for<T, K>(model: import("../models/model").ListenableModel<K, T>, callback: (value: T, index: K) => void): void;
    watch<T_1>(model: import("../index").IValue<T_1>, callback: (value: T_1) => void): void;
    nextTick(callback: () => void): void;
    ref(value: any): import("../index").IValue<any>;
    expr: typeof expr;
    of: typeof valueOf;
    sv: typeof setValue;
    alwaysFalse: Reference<boolean>;
    app: typeof app;
    component: typeof component;
    fragment: typeof fragment;
    extension: typeof extension;
    text: typeof text;
    tag: typeof tag;
    create: typeof create;
};
